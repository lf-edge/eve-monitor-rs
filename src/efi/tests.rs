// Copyright (c) 2025 Zededa, Inc.
// SPDX-License-Identifier: Apache-2.0

use crate::efi::{
    device_path::PathNode,
    vars::{EfiBootOrder, EfiLoadOption, LoadOptionAttributes},
};
use anyhow::Result;

#[test]
fn test_efi_load_option() {
    let data = [
        0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x55, 0x00, 0x45, 0x00, 0x46,
        0x00, 0x49, 0x00, 0x20, 0x00, 0x4f, 0x00, 0x53, 0x00, 0x00, 0x00, 0x04, 0x01, 0x2a, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x71, 0x68, 0xad, 0xf9, 0x31, 0xf3, 0x4c, 0x9e, 0x09,
        0x6f, 0x7a, 0x25, 0xc3, 0x00, 0x51, 0x02, 0x02, 0x04, 0x04, 0x30, 0x00, 0x5c, 0x00, 0x45,
        0x00, 0x46, 0x00, 0x49, 0x00, 0x5c, 0x00, 0x42, 0x00, 0x4f, 0x00, 0x4f, 0x00, 0x54, 0x00,
        0x5c, 0x00, 0x42, 0x00, 0x4f, 0x00, 0x4f, 0x00, 0x54, 0x00, 0x58, 0x00, 0x36, 0x00, 0x34,
        0x00, 0x2e, 0x00, 0x45, 0x00, 0x46, 0x00, 0x49, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x04, 0x00,
        0x00, 0x00, 0x42, 0x4f,
    ];

    let efi_load_option = EfiLoadOption::parse_linux_efi_var(&data).unwrap();

    assert_eq!(efi_load_option.description, "UEFI OS");
    assert_eq!(efi_load_option.attributes.is_category_boot(), true);
    assert_eq!(efi_load_option.attributes.is_active(), true);
    assert_eq!(efi_load_option.attributes.is_hidden(), false);
    assert_eq!(efi_load_option.device_path_list.nodes.len(), 0x3);
}

#[test]
fn test_efi_load_option_no_null_terminator_in_description() {
    let data = [
        0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x55, 0x00, 0x45, 0x00, 0x46,
        0x00, 0x49, 0x00, 0x20, 0x00, 0x4f, 0x00, 0x53, 0x00, 0x55, 0x00, 0x04, 0x01, 0x2a, 0x00,
        0x01,
    ];

    let efi_load_option = EfiLoadOption::parse_linux_efi_var(&data);

    match efi_load_option {
        Err(e) => {
            assert_eq!(e.to_string(), "missing null terminator")
        }
        _ => panic!("Expected error"),
    }
}

#[test]
fn test_efi_load_option_insafitient_data() {
    let data = [
        0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x55, 0x00, 0x45, 0x00, 0x46,
        0x00, 0x49, 0x00, 0x20, 0x00, 0x4f, 0x00, 0x53, 0x00, 0x55, 0x00, 0x04, 0x01, 0x2a, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x71, 0x68, 0xad, 0xf9, 0x31, 0xf3, 0x4c, 0x9e, 0x09,
        0x6f, 0x7a, 0x25, 0xc3, 0x00, 0x51, 0x02, 0x02, 0x04, 0x04, 0x30, 0x00, 0x5c, 0x00, 0x45,
        0x00, 0x46, 0x00, 0x49, 0x00, 0x5c, 0x00, 0x42, 0x00, 0x4f, 0x00, 0x4f, 0x00, 0x54, 0x00,
        0x5c, 0x00, 0x42, 0x00, 0x4f, 0x00, 0x4f, 0x00, 0x54, 0x00, 0x58, 0x00, 0x36, 0x00, 0x34,
        0x00, 0x2e, 0x00, 0x45, 0x00, 0x46, 0x00, 0x49, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x04, 0x00,
        0x00, 0x00, 0x42, 0x4f,
    ];

    let efi_load_option = EfiLoadOption::parse_linux_efi_var(&data);

    match efi_load_option {
        Err(e) => {
            assert_eq!(e.to_string(), "failed to fill whole buffer")
        }
        _ => panic!("Expected error"),
    }
}

#[test]
fn test_boot_inacitve() -> Result<()> {
    let data = [
        0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x18, 0x00, 0x53, 0x00, 0x65, 0x00, 0x74,
        0x00, 0x75, 0x00, 0x70, 0x00, 0x00, 0x00, 0x04, 0x06, 0x14, 0x00, 0x66, 0x8b, 0x1c, 0x72,
        0x6c, 0x42, 0x86, 0x4e, 0x8e, 0x99, 0x34, 0x57, 0xc4, 0x6a, 0xb0, 0xb9, 0x7f, 0xff, 0x04,
        0x00,
    ];
    let efi_load_option = EfiLoadOption::parse_linux_efi_var(&data)?;

    assert_eq!(efi_load_option.attributes.is_active(), false);
    assert_eq!(efi_load_option.attributes.is_hidden(), false);
    assert_eq!(efi_load_option.attributes.is_category_boot(), false);
    assert_eq!(efi_load_option.device_path_list.nodes.len(), 0x2);
    assert_eq!(
        efi_load_option.device_path_list.nodes[0],
        PathNode::Media(crate::efi::device_path::media::MediaNode::FvFile(
            uuid::uuid!("721c8b66-426c-4e86-8e99-3457c46ab0b9")
        ))
    );
    assert_eq!(
        efi_load_option.device_path_list.nodes[1],
        PathNode::EndEntire
    );
    assert_eq!(efi_load_option.description, "Setup");
    Ok(())
}

#[test]
fn test_boot_order() {
    let data = [
        0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x1d, 0x00, 0x1e, 0x00, 0x1f,
        0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x24, 0x00, 0x01, 0x00,
    ];

    let efi_boot_order = EfiBootOrder::parse_linux_efi_var(&data).unwrap();

    assert_eq!(
        efi_boot_order.boot_order,
        vec![
            0x0002, 0x0000, 0x001C, 0x001D, 0x001E, 0x001F, 0x0020, 0x0021, 0x0022, 0x0023, 0x0024,
            0x0001
        ]
    );
}

#[test]
fn test_boot_order_insafitient_data() {
    let data = [
        0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x1d, 0x00, 0x1e, 0x00, 0x1f,
        0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x24, 0x00, 0x01,
    ];

    let efi_boot_order = EfiBootOrder::parse_linux_efi_var(&data);

    match efi_boot_order {
        Err(e) => {
            assert_eq!(e.to_string(), "failed to fill whole buffer")
        }
        _ => panic!("Expected error"),
    }
}

#[test]
fn test_attr_all() {
    let attr: u32 = 0x0000_010B;
    let attributes = LoadOptionAttributes::try_from(attr).unwrap();
    assert_eq!(attributes.is_active(), true);
    assert_eq!(attributes.is_force_reconnect(), true);
    assert_eq!(attributes.is_hidden(), true);
    assert_eq!(attributes.is_category_app(), true);
}

#[test]
fn test_attr_active() {
    let attr: u32 = 0x0000_0001;
    let attributes = LoadOptionAttributes::try_from(attr).unwrap();
    assert_eq!(attributes.is_active(), true);
    assert_eq!(attributes.is_force_reconnect(), false);
    assert_eq!(attributes.is_hidden(), false);
    assert_eq!(attributes.is_category_app(), false);
}

#[test]
fn test_attr_incorrect() {
    let attr: u32 = 0xFFFF_FEF4;
    let attributes = LoadOptionAttributes::try_from(attr);
    match attributes {
        Err(e) => {
            assert_eq!(e.to_string(), format!("UnsupportedAttributes: {}", attr))
        }
        _ => panic!("Expected error"),
    }
}
